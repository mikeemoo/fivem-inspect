/*! For license information please see client.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./node_modules/fast-deep-equal/index.js":module=>{eval("\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n\n//# sourceURL=webpack://fivem-inspect/./node_modules/fast-deep-equal/index.js?")},"./src/client/client.ts":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js");\n/* harmony import */ var fast_deep_equal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_deep_equal__WEBPACK_IMPORTED_MODULE_0__);\n\r\nvar EntityType;\r\n(function (EntityType) {\r\n    EntityType[EntityType["NoEntity"] = 0] = "NoEntity";\r\n    EntityType[EntityType["Ped"] = 1] = "Ped";\r\n    EntityType[EntityType["Vehicle"] = 2] = "Vehicle";\r\n    EntityType[EntityType["Object"] = 3] = "Object";\r\n})(EntityType || (EntityType = {}));\r\nconst RADIANS = Math.PI / 180;\r\nconst entityCallbacks = {};\r\nconst sphereCallbacks = {};\r\nlet currentMenuItems = [];\r\nlet menuIsOpen = false;\r\nlet previousEntityId = -1;\r\nconst raycastInfrontOfCamera = async (cameraCoord, cameraVec) => {\r\n    const destination = cameraVec.map((direction, i) => cameraCoord[i] + direction * 10);\r\n    const shapeTest = StartShapeTestSweptSphere(cameraCoord[0], cameraCoord[1], cameraCoord[2], destination[0], destination[1], destination[2], 0.3, -1, PlayerPedId(), 7);\r\n    return GetShapeTestResult(shapeTest);\r\n};\r\nconst unregister = () => {\r\n    const invokingResource = GetInvokingResource();\r\n    delete entityCallbacks[invokingResource];\r\n    delete sphereCallbacks[invokingResource];\r\n};\r\nconst registerInspectSpheres = (spheres, callback) => {\r\n    const invokingResource = GetInvokingResource();\r\n    if (!sphereCallbacks[invokingResource]) {\r\n        sphereCallbacks[invokingResource] = [];\r\n    }\r\n    sphereCallbacks[invokingResource].push({\r\n        spheres,\r\n        callback\r\n    });\r\n};\r\nconst registerInspectEntity = (callback) => {\r\n    const invokingResource = GetInvokingResource();\r\n    if (!entityCallbacks[invokingResource]) {\r\n        entityCallbacks[invokingResource] = [];\r\n    }\r\n    entityCallbacks[invokingResource].push(callback);\r\n};\r\nconst closeMenu = () => {\r\n    SendNuiMessage(JSON.stringify({\r\n        action: "closeMenu"\r\n    }));\r\n    SetNuiFocus(false, false);\r\n    menuIsOpen = false;\r\n};\r\nconst openMenu = () => {\r\n    SetCursorLocation(0.5, 0.5);\r\n    SendNuiMessage(JSON.stringify({\r\n        action: "openMenu",\r\n        menuItems: currentMenuItems\r\n    }));\r\n    SetNuiFocus(true, true);\r\n    menuIsOpen = true;\r\n};\r\nsetInterval(async () => {\r\n    const nextMenuItems = [];\r\n    const cameraCoord = GetGameplayCamCoord();\r\n    const playerCoords = GetEntityCoords(PlayerPedId(), true);\r\n    const [rx, _, rz] = GetGameplayCamRot(0).map((r) => RADIANS * r);\r\n    const cameraVec = [\r\n        -Math.sin(rz) * Math.abs(Math.cos(rx)),\r\n        Math.cos(rz) * Math.abs(Math.cos(rx)),\r\n        Math.sin(rx)\r\n    ];\r\n    let [retval, hit, , , entityId] = await raycastInfrontOfCamera(cameraCoord, cameraVec);\r\n    if (retval && hit) {\r\n        const entityType = GetEntityType(entityId);\r\n        if (entityType !== EntityType.NoEntity) {\r\n            // we\'ve got an entity, but it\'s different from the previous entity, so lets make sure our menu is closed\r\n            if (menuIsOpen && entityId !== previousEntityId) {\r\n                closeMenu();\r\n            }\r\n            // grab the model upfront to avoid every callback having to do it\r\n            const entityModel = GetEntityModel(entityId);\r\n            Object.values(entityCallbacks)\r\n                .flat()\r\n                .map((callback) => callback(entityId, EntityType[entityType].toLowerCase(), entityModel))\r\n                .filter((a) => !!a)\r\n                .flat()\r\n                .forEach((item) => nextMenuItems.push(item));\r\n        }\r\n        else {\r\n            entityId = -1;\r\n        }\r\n    }\r\n    else {\r\n        entityId = -1;\r\n    }\r\n    Object.values(sphereCallbacks)\r\n        .flat()\r\n        .filter((sphereInfo) => sphereInfo.spheres.some(({ x, y, z, radius }) => {\r\n        if (Vdist2(x, y, z, playerCoords[0], playerCoords[1], playerCoords[2]) > (radius + 4) ** 2) {\r\n            return false;\r\n        }\r\n        const distToSphere = Math.sqrt(((x - cameraCoord[0]) ** 2) +\r\n            ((y - cameraCoord[1]) ** 2) +\r\n            ((z - cameraCoord[2]) ** 2));\r\n        const destination = cameraVec.map((direction, i) => cameraCoord[i] + direction * distToSphere);\r\n        return ((x - destination[0]) ** 2) +\r\n            ((y - destination[1]) ** 2) +\r\n            ((z - destination[2]) ** 2) < (radius ** 2);\r\n    }))\r\n        .map((sphereInfo) => sphereInfo.callback())\r\n        .filter((a) => !!a)\r\n        .flat()\r\n        .forEach((item) => nextMenuItems.push(item));\r\n    // lets not bother sending a message to NUI if everything is identical\r\n    if (!fast_deep_equal__WEBPACK_IMPORTED_MODULE_0___default()(nextMenuItems, currentMenuItems)) {\r\n        SendNuiMessage(JSON.stringify({\r\n            action: "setMenuItems",\r\n            menuItems: nextMenuItems\r\n        }));\r\n    }\r\n    // the menu is open but there\'s nothing in it (or just a single item), lets close it.\r\n    if (menuIsOpen && nextMenuItems.length <= 1) {\r\n        closeMenu();\r\n    }\r\n    previousEntityId = entityId;\r\n    currentMenuItems = nextMenuItems;\r\n}, 100);\r\n// NUI has requested that we close (either through Escape or clicking off a menu)\r\nRegisterNuiCallbackType("closeUI");\r\non("__cfx_nui:closeUI", ({}, cb) => {\r\n    closeMenu();\r\n    cb({});\r\n});\r\n// an item in a menu was clicked, so lets fire the event\r\nRegisterNuiCallbackType("itemClicked");\r\non("__cfx_nui:itemClicked", (menuItem, cb) => {\r\n    closeMenu();\r\n    emit(menuItem.eventName, menuItem.arguments);\r\n    cb({});\r\n});\r\nlet enableDebug = false;\r\nsetTick(() => {\r\n    if (enableDebug) {\r\n        const sphereLists = Object.values(sphereCallbacks)\r\n            .flat()\r\n            .map((a) => a.spheres)\r\n            .flat()\r\n            .forEach(({ x, y, z, radius }) => {\r\n            DrawMarker(28, x, y, z, 0, 0, 0, 0, 0, 0, radius, radius, radius, 0, 255, 0, 100, false, false, 2, false, null, null, false);\r\n        });\r\n    }\r\n});\r\nRegisterCommand("inspect:debug", (_source, [enabled]) => {\r\n    enableDebug = enabled === "true" || enabled === "1";\r\n}, false);\r\nRegisterCommand("+inspect", () => {\r\n    // nothing to inspect. lets bail.\r\n    if (currentMenuItems.length === 0) {\r\n        return;\r\n    }\r\n    // only a single item, so lets fire that item\r\n    if (currentMenuItems.length === 1) {\r\n        emit(currentMenuItems[0].eventName, currentMenuItems[0].arguments);\r\n        return;\r\n    }\r\n    // looks like we have multiple items. lets open the menu\r\n    openMenu();\r\n}, false);\r\nRegisterKeyMapping("+inspect", "Inspect", "keyboard", "e");\r\n__webpack_require__.g.exports("unregister", unregister);\r\n__webpack_require__.g.exports("registerInspectEntity", registerInspectEntity);\r\n__webpack_require__.g.exports("registerInspectSpheres", registerInspectSpheres);\r\n\n\n//# sourceURL=webpack://fivem-inspect/./src/client/client.ts?')}},__webpack_module_cache__={};function __webpack_require__(e){var n=__webpack_module_cache__[e];if(void 0!==n)return n.exports;var r=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e](r,r.exports,__webpack_require__),r.exports}__webpack_require__.n=e=>{var n=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(n,{a:n}),n},__webpack_require__.d=(e,n)=>{for(var r in n)__webpack_require__.o(n,r)&&!__webpack_require__.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:n[r]})},__webpack_require__.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),__webpack_require__.o=(e,n)=>Object.prototype.hasOwnProperty.call(e,n),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./src/client/client.ts")})();